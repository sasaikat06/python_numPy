\documentclass[openany]{book}
\usepackage{hyperref}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{geometry}
\geometry{
    left = 0.5in,
    right= 0.5in,
    top = 1in,
    bottom = 1in
}

\title{Numerical Python}
\author{Shishir Ahmed Saikat}
\date{\today}
\begin{document}

\frontmatter % 

\maketitle{}
\tableofcontents

\mainmatter %Main content


%\maketitle{Introduction}
\chapter{Introduction}
\section{Introduction}
NumPy is a Python library.
NumPy is used for working with \textbf{arrays}. \\
It also has functions for working in domain of linear algebra, fourier transform and matrices.\\


\subsection{Why use NumPy}
NumPy aims to provide an array object that is up to 50x faster than traditional Python lists. The array object in NumPy is called \textbf{\underline{ndarray}}, it provides a lot of supporting functions that make working with \textbf{\underline{ndarray}} very easy. 

\subsection{Why is NumPy Faster Than List?}

NumPy arrays are \textbf{stored at one continuous place} in memory unlike lists, so processes can access and manipulate them very efficiently.

\subsection{Which Language is NumPy Written in ?}

NumPy is a Python library written partially in Python, but most of the parts that required fast computation are written in C or C++ . The source code for NumPy is located at this {https://www.github.com/numpy/numpy} github repository


\maketitle{Creating Arrays}
\chapter{Creating Arrays}
\section{Create a ndarray Object}


\hbox{NumPy is used to work with arrays. The array object in NumPy is called \emph{ndarray} \\
We can create a NumPy \emph{ndarray} object by using \emph{array()} function. \\ \\
To create an \emph{ndarray}, we can pass a \textbf{list,tuple or any array like object} into \emph{array()} method and it will be converted into an \emph{ndarray} }

\subsection{Dimensions in Arrays}
A dimension in arrays is one level of array depth (nested arrays)
.We have several types of array in NumPy. They are;

\begin{enumerate}
    \item 0-D Arrays $\rightarrow$ Only one item in arroy
    \item 1-D Arrays  $\rightarrow$ Most basic and common arrays
    \item 2-D Arrays  $\rightarrow$ An array has 1-D  arrays as its element. (Nested array in 1-D)
    \item 3-D Arrays  $\rightarrow$ An array has 2-D  arrays as its element. (Nested array in 1-D)
\end{enumerate}

\textbf{For multidimensional array, the number of elements in each nested array must be identical!}
To return the dimension of the array $\rightarrow$ \textit{ndim}

\subsection{Higher dimensional Arrays}

An array can have any number of dimensions. \\
When the array is created, we can define the number of dimensions bu using the \textbf{\textit{ndim}} argument.

\textbf{Example}
\\
arr = np.array([1,2,4,5], ndmin=8)\\
\section{Array Indexing}

Array indexing is the same as accessing an array element. \\
We can access an array element by referring to its index number. \\
The indexes in NumPy arrays start with 0, meaning that the index of first element is 0, and the 1 is for the second element and up to up... \\
\subsection{Access Array Elements}


\begin{enumerate}
    \item To access 1-D Arrays $\rightarrow$ variable[n]
    \item To access 2-D Arrays $\rightarrow$ variable[n,m]
    \item To access 3-D Arrays $\rightarrow$ variable[n,m,l]
    \item For negative Indexing $\rightarrow$ variable[n,-m]
\end{enumerate}
To access 1-D Arrays $\rightarrow$ variable[n]


\section{Array Slicing}


Slicing means taking elements from one given index to another given index. \\
We pass slice instead of index like this : [start:end] \\
We can also define the step, like this: [start:end:step]\\
If we don't pass start its considered \textbf{0}
If we don't pass end its considered \textbf{length of array} in that dimension. \\
If we don't pass step its considerde 1.\\
When we select a range such that [m:n] the result returns from index m to (n-1) index. 
But for nested array this rule is not fllowed. In that case, for [m:n, p:q] , it is taken ,for m:n from index \textbf{m to (n-1)} and for p:q \textbf{p to q}

\subsection{1-D}
variable[start:end]

arr = np.array([1,2,3,4,5,6]) \\
print(arr[1:5]) \\
It will return: 2 3 4 

print(arr[1:])  (Slice elements from index 1 to the end of the array)\\  
It will return: 2 3 4 5 6 

print(arr[:4]) (Slice elements from the beginnig to index 4 (not included)) \\
It will return: 1 2 3
\\

\subsection{Step}
If we don't pass step its considered 1.\\
\\
arr = np.array([1,2,3,4,5,6,7,8,9])
\\
print(arr(1:6:2)) \\
Result: 2 4 6 \\

print(arr[::2]) \\
Result: 1 3 5 7 9 \\


\subsection{2-D}
arr = np.array([[1,2,3,4,5],[11,12,13,14,15]]) \\


print(arr[0:2,3]) \\ \\
here, \\ arr[0:2,3] is saying that go throug the array of index 0 and 1 and slice the element of index 3 from each.
 \\
  Hence,   0:2 indicating the index of main array and 3 is indicating the element of nested array and \\

Result : 4 14 \\ \\



Again, print(arr[0:2,1:4]) \\

It is saying that go through the array of index 0 and 1 and then slice elements from index 1 to 4 \\

Here, Result: [2 3 4] [12 13 14]
\newpage

\section{Array Copy vs View}
The main difference between \textbf{copy} and \textbf{view} is that the \textbf{copy} is a new array, on the other hand  \textbf{view} is just a view of original array! \\ \\
Actually, the behaviour of \textbf{copy()} and \textbf{view} is as natural. The \textbf{copy} method just copy the original array and \textbf{view()} method just show us the original array. So if we make change in the original array the copied one will \textbf{not be affected} and will return the actual array what we copied. But for \textbf{view} we will show the changed array!\\ \\

\textbf{copy()} method owns the array but \textbf{view()} don't.
\\ 
\underline{Example:} \\
import numpy as np \\
arr = np.array([1,2,3,4,5,0]) \\

newarr = arr.copy() \\
view = arr.view()\\
arr[0] = 42\\


print(arr) $\rightarrow$ [42  2  3  4  5  0] \\
print(newarr) $\rightarrow$ [1 2 3 4 5 0]\\
print(view) $\rightarrow$ [42  2  3  4  5  0]\\

To check that an array owns the data from another one $\rightarrow$ variable.base $\rightarrow$ it will return \textbf{None} if it owns otherwise it will return the original object
\chapter{Data Types}

\section{Data Types in Python}
By default Python have these data types;
\begin{enumerate}
    \item string
    \item integer
    \item float
    \item boolean
    \item complex
\end{enumerate}

\section{Data Types in NumPy}

\paragraph{NumPy has some extra data types, and refer to data types with one character, like \textit{i} for integer, \textit{u} for unsigned integers etc.}

\begin{enumerate}
    \item i $\rightarrow$ integer
    \item b $\rightarrow$ boolean
    \item u $\rightarrow$ unsigned integer
    \item f $\rightarrow$ float
    \item c $\rightarrow$ complex float
    \item m $\rightarrow$ timedelta
    \item M $\rightarrow$ datetime
    \item O $\rightarrow$ object
    \item S $\rightarrow$ string
    \item U $\rightarrow$ unicode string
    \item V $\rightarrow$ fixed chunk of memory for other type (void)
\end{enumerate}

We can define or change the data-type of an array simply writing \textbf{\textit{dtype=`S`}} after the array \\
We also can define the size of this data type as well! simply writing \textbf{\textit{dtype=`S4`}} after the array \\
We know strings like 'hello, a, B etc.' cannot be converted to integer value. So, if we want cast them to integer, will rise an error called ValueError \\

Here the best way to change the data type of an existing array, is to make a copy of the array with the \textbf{\textit{astype()}} method. It created a copy of data and allows to specify the data type as parameter.\\
 \underline{e.g:} arr = np.array([[1,2,3,4,5],[11,12,13,14,15]],dtype="S") 

newarr = arr.astype("i")

\chapter{Array Shape}
\section{Shape of Array}
The shape of an array is the number of elements in each dimension. \\
To get the shape of an array use the attribute \textit{shape}.\\
If there is an array like : arr = np.array([[1,2,4,5],[1,4,5,6]]) and if we call it by arr.shape then it will return 2,4 . Here 2 is the number of array and 4 is the dimension. \\

On the other hand, if we create an array like this, \\
arr = np.array([1,2,3],ndmin=5) and print arr.shape then it will show us 1,1,1,1,3 . Here the written array will be at last!

\section{Array Reshaping}
Reshaping means changing the shape of an array, or convert the dimention. \\
The shape of an array is the number of elements in each dimension. \\
By reshaping we can add or remobe dimensions or change number of elements in each dimension. \\
Note that, it is not a copy a copy it is view (See 2.4)
\begin{enumerate}
    \item [[1,2]] $\rightarrow$ 1-D 
    \item [[1,2],[3,4]] $\rightarrow$ 2-D
    \item [[[1,2],[2,3]]] $\rightarrow$ 3-D
\end{enumerate}
Simply, if we count the number of square brackets at begin , it will tell us the dimension ;\,)
\subsection{From 1-D to 2-D}
Suppose we have 12 elements in an array (1-D), now we want to separate them into two array(2-D). To do that ; \\
arr = np.array([1,2,3,4,5,6,7,8,9,10,11,12]) \\
newArray = arr.reshape(2,6) \\
now, if we print newArray it will  return us [[ 1  3  5  6  7  8]
[ 9  3 45  6  4  5]] \\
arr.reshape(2,6), here 2 indicates the dimension of main array and 6 indicates the dimension of each nested array. 
\subsection{From 1-D to 2-D}
It is similar as before, but here we will pass 3 argument into \textit{reshape()} instead of 2 argument. \\
e.g: arr.reshape(2,3,2)
\\
\textbf{Let, we have an array of \textit(x) number of elements and we want to reshape into \textit{n} dimension, but do not want to specify the number of element of each nested array then if we use -1 after defining dimention, NumPy will calculate the number of elements for each nested array!} \\
\subsubsection*{Suppose, we have 16 elements in a single array(1-D), now if we want to convert them into 2-D array, then if we write .reshape(2,-1) then it will return us 2-D array [ 2 nested array, each having 8 elements]}

\subsection{From 1-D to 3-D}
It is similar as 4.2.2 , additionally we will define a 3-D array into reshape(3,2,2). If the number of elements into an array is 12 then for .reshape(3,2,2) will return us 3* 2-D array each of 2 elements, which is altogether a 3-D array. //
Similar as before, if we do not want to define the number of elements in the nested(last) array we can use -1.

\subsection{Multi-D to 1-D}
To convert 2-D/3-D/...n-D array into 1-D array, we can use \textit{.reshape(-1)}. It is called Flattening. \\

\textbf{NB:} There are a lot of functions for changing the shapes of arrays in numpy flatten, ravel and also for rearranging the elements rot90, flip, fliplr, flipud etc. These fall under Intermediate to Advanced section of numpy.

\textbf{NB:} .reshape(n,m,l) ; n*m*l is must be equal to the number of elements in the array!



\chapter{Array Iteration}
Iterating means going through elements one by one. \\

As we deal with multi-dimensional arrays in numpy, we can do this using basic for loop of python. \\

If we iterate on a 1-D array it will go through each element one by one.\\

In a 2-D array it will go through all the row also the elements. To get only the rows, use only the first iteration. \\

In a d-D array it will go through all the row also the elements. To get only the rows, use  first two iterations.


\begin{tabular}{|p{4cm}|p{6cm}|p{8.5cm}|}
    \hline
    1-D & 2-D & 3-D \\
    \hline
arr = np.array([1, 2, 3]) &  arr = np.array([[1, 2, 3], [4, 5, 6]]) &     arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]) \\
for x in arr: & for x in arr: & for x in arr:\\
print(x) & for y in x: & for y in x: \\
& print(y) & for z in y \\
& & print(z) \\
\hline
\end{tabular}

\chapter{In Brief}

\begin{enumerate}
    \item To check dimension/s $\rightarrow$ variable.ndim 
    \item To define the dimension of an Array $\rightarrow$ ndmin = n 
    \item To check the datatype of an array $\rightarrow$ variable.dtype
    \item To copy,store and convert data type $\rightarrow$ newArray = prevArray.astype("i/S/bool...")
    \item To access 1-D Arrays $\rightarrow$ variable[n]
    \item To access 2-D Arrays $\rightarrow$ variable[n,m]
    \item To access 3-D Arrays $\rightarrow$ variable[n,m,l]
    \item For negative Indexing $\rightarrow$ variable[n,-m]
    \item Slice 1-D Array $\rightarrow$ variable[n:m] (from n to m-1)
    \item To use Step $\rightarrow$ variable[n:m:a] (a is step)
    \item To use Step $\rightarrow$ variable[::a] (return element from begining to end after "a" number of step)
    \item Slice 2-D Array $\rightarrow$ variable[n:m,p:q] (from n to m-1 and p to q)
    \item To copy an array $\rightarrow$ variable.copy()
    \item To show the original array $\rightarrow$ variable.view()
    \item To check that an array owns the data from another one $\rightarrow$ variable.base $\rightarrow$ it will return \textbf{None} if it owns otherwise it will return the original object
    \item To know the shape/size of an array $\rightarrow$ variable.shape
    \item To reshape 2-D array $\rightarrow$ var.reshape(2,n) or reshahpe(2,-1)
    \item To reshape 3-D array $\rightarrow$ var.reshape(2,2,n) or reshahpe(2,2,-1)
    \item To reshape from multi-D to 1-D $\rightarrow$ var.reshape(-1)
\end{enumerate}
\newpage

\section{Rights}

\paragraph{The contents of this PDF are largely derived (approximately 98\%) from W3Schools. It is not intended for commercial use; rather, I have compiled it as personal study notes. Feel free for anyone to read or integrate this material.}

\cleardoublepage

\end{document}
