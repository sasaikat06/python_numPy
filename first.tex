\documentclass[openany]{book}
\usepackage{hyperref}
\title{Numerical Python}
\author{Shishir Ahmed Saikat}
\date{\today}
\begin{document}

\frontmatter % 

\maketitle{}
\tableofcontents

\mainmatter %Main content


%\maketitle{Introduction}
\chapter{Introduction}
\section{Introduction}
{NumPy is a Python library.
NumPy is used for working with \textbf{arrays}. \\
It also has functions for working in domain of linear algebra, fourier transform and matrices.\\
}

\subsection{Why use NumPy}
NumPy aims to provide an array object that is up to 50x faster than traditional Python lists. The array object in NumPy is called \textbf{\underline{ndarray}}, it provides a lot of supporting functions that make working with \textbf{\underline{ndarray}} very easy. 

\subsection{Why is NumPy Faster Than List?}

NumPy arrays are \textbf{stored at one continuous place} in memory unlike lists, so processes can access and manipulate them very efficiently.

\subsection{Which Language is NumPy Written in ?}

NumPy is a Python library written partially in Python, but most of the parts that required fast computation are written in C or C++ . The source code for NumPy is located at this {https://www.github.com/numpy/numpy} github repository


\maketitle{Creating Arrays}
\chapter{Creating Arrays}
\section{Create a ndarray Object}


\hbox{NumPy is used to work with arrays. The array object in NumPy is called \emph{ndarray} \\
We can create a NumPy \emph{ndarray} object by using \emph{array()} function. \\ \\
To create an \emph{ndarray}, we can pass a \textbf{list,tuple or any array like object} into \emph{array()} method and it will be converted into an \emph{ndarray} }

\subsection{Dimensions in Arrays}
A dimension in arrays is one level of array depth (nested arrays)
.We have several types of array in NumPy. They are;

\begin{enumerate}
    \item 0-D Arrays $\rightarrow$ Only one item in arroy
    \item 1-D Arrays  $\rightarrow$ Most basic and common arrays
    \item 2-D Arrays  $\rightarrow$ An array has 1-D  arrays as its element. (Nested array in 1-D)
    \item 3-D Arrays  $\rightarrow$ An array has 2-D  arrays as its element. (Nested array in 1-D)
\end{enumerate}

\textbf{For multidimensional array, the number of elements in each nested array must be identical!}
To return the dimension of the array $\rightarrow$ \textit{ndim}

\subsection{Higher dimensional Arrays}

An array can have any number of dimensions. \\
When the array is created, we can define the number of dimensions bu using the \textbf{\textit{ndim}} argument.

\textbf{Example}
\\
arr = np.array([1,2,4,5], ndmin=8)\\
\section{Array Indexing}

Array indexing is the same as accessing an array element. \\
We can access an array element by referring to its index number. \\
The indexes in NumPy arrays start with 0, meaning that the index of first element is 0, and the 1 is for the second element and up to up... \\
\subsection{Access Array Elements}


\begin{enumerate}
    \item To access 1-D Arrays $\rightarrow$ variable[n]
    \item To access 2-D Arrays $\rightarrow$ variable[n,m]
    \item To access 3-D Arrays $\rightarrow$ variable[n,m,l]
    \item For negative Indexing $\rightarrow$ variable[n,-m]
\end{enumerate}
To access 1-D Arrays $\rightarrow$ variable[n]


\section{Array Slicing}


Slicing means taking elements from one given index to another given index. \\
We pass slice instead of index like this : [start:end] \\
We can also define the step, like this: [start:end:step]\\
If we don't pass start its considered \textbf{0}
If we don't pass end its considered \textbf{length of array} in that dimension. \\
If we don't pass step its considerde 1.\\
When we select a range such that [m:n] the result returns from index m to (n-1) index. 
But for nested array this rule is not fllowed. In that case, for [m:n, p:q] , it is taken ,for m:n from index \textbf{m to (n-1)} and for p:q \textbf{p to q}

\subsection{1-D}
variable[start:end]

arr = np.array([1,2,3,4,5,6]) \\
print(arr[1:5]) \\
It will return: 2 3 4 

print(arr[1:])  (Slice elements from index 1 to the end of the array)\\  
It will return: 2 3 4 5 6 

print(arr[:4]) (Slice elements from the beginnig to index 4 (not included)) \\
It will return: 1 2 3
\\

\subsection{Step}
If we don't pass step its considered 1.\\
\\
arr = np.array([1,2,3,4,5,6,7,8,9])
\\
print(arr(1:6:2)) \\
Result: 2 4 6 \\

print(arr[::2]) \\
Result: 1 3 5 7 9 \\


\subsection{2-D}
arr = np.array([[1,2,3,4,5],[11,12,13,14,15]]) \\


print(arr[0:2,3]) \\ \\
here, \\ arr[0:2,3] is saying that go throug the array of index 0 and 1 and slice the element of index 3 from each.
 \\
  Hence,   0:2 indicating the index of main array and 3 is indicating the element of nested array and \\

Result : 4 14 \\ \\



Again, print(arr[0:2,1:4]) \\

It is saying that go through the array of index 0 and 1 and then slice elements from index 1 to 4 \\

Here, Result: [2 3 4] [12 13 14]
\newpage

\section{Array Copy vs View}
The main difference between \textbf{copy} and \textbf{view} is that the \textbf{copy} is a new array, on the other hand  \textbf{view} is just a view of original array! \\ \\
Actually, the behaviour of \textbf{copy()} and \textbf{view} is as natural. The \textbf{copy} method just copy the original array and \textbf{view()} method just show us the original array. So if we make change in the original array the copied one will \textbf{not be affected} and will return the actual array what we copied. But for \textbf{view} we will show the changed array!\\ \\

\textbf{copy()} method owns the array but \textbf{view()} don't.
\\ 
\underline{Example:} \\
import numpy as np \\
arr = np.array([1,2,3,4,5,0]) \\

newarr = arr.copy() \\
view = arr.view()\\
arr[0] = 42\\


print(arr) $\rightarrow$ [42  2  3  4  5  0] \\
print(newarr) $\rightarrow$ [1 2 3 4 5 0]\\
print(view) $\rightarrow$ [42  2  3  4  5  0]\\

To check that an array owns the data from another one $\rightarrow$ variable.base $\rightarrow$ it will return \textbf{None} if it owns otherwise it will return the original object
\chapter{Data Types}

\section{Data Types in Python}
By default Python have these data types;
\begin{enumerate}
    \item string
    \item integer
    \item float
    \item boolean
    \item complex
\end{enumerate}

\section{Data Types in NumPy}

\paragraph{NumPy has some extra data types, and refer to data types with one character, like \textit{i} for integer, \textit{u} for unsigned integers etc.}

\begin{enumerate}
    \item i $\rightarrow$ integer
    \item b $\rightarrow$ boolean
    \item u $\rightarrow$ unsigned integer
    \item f $\rightarrow$ float
    \item c $\rightarrow$ complex float
    \item m $\rightarrow$ timedelta
    \item M $\rightarrow$ datetime
    \item O $\rightarrow$ object
    \item S $\rightarrow$ string
    \item U $\rightarrow$ unicode string
    \item V $\rightarrow$ fixed chunk of memory for other type (void)
\end{enumerate}

We can define or change the data-type of an array simply writing \textbf{\textit{dtype=`S`}} after the array \\
We also can define the size of this data type as well! simply writing \textbf{\textit{dtype=`S4`}} after the array \\
We know strings like 'hello, a, B etc.' cannot be converted to integer value. So, if we want cast them to integer, will rise an error called ValueError \\

Here the best way to change the data type of an existing array, is to make a copy of the array with the \textbf{\textit{astype()}} method. It created a copy of data and allows to specify the data type as parameter.\\
 \underline{e.g:} arr = np.array([[1,2,3,4,5],[11,12,13,14,15]],dtype="S") 

newarr = arr.astype("i")

\chapter{Array Shape}

\chapter{In Brief}

\begin{enumerate}
    \item To check dimension/s $\rightarrow$ variable.ndim 
    \item To define the dimension of an Array $\rightarrow$ ndmin = n 
    \item To check the datatype of an array $\rightarrow$ variable.dtype
    \item To copy,store and convert data type $\rightarrow$ newArray = prevArray.astype("i/S/bool...")
    \item To access 1-D Arrays $\rightarrow$ variable[n]
    \item To access 2-D Arrays $\rightarrow$ variable[n,m]
    \item To access 3-D Arrays $\rightarrow$ variable[n,m,l]
    \item For negative Indexing $\rightarrow$ variable[n,-m]
    \item Slice 1-D Array $\rightarrow$ variable[n:m] (from n to m-1)
    \item To use Step $\rightarrow$ variable[n:m:a] (a is step)
    \item To use Step $\rightarrow$ variable[::a] (return element from begining to end after "a" number of step)
    \item Slice 2-D Array $\rightarrow$ variable[n:m,p:q] (from n to m-1 and p to q)
    \item To copy an array $\rightarrow$ variable.copy()
    \item To show the original array $\rightarrow$ variable.view()
    \item To check that an array owns the data from another one $\rightarrow$ variable.base $\rightarrow$ it will return \textbf{None} if it owns otherwise it will return the original object
    \item To know the shape/size of an array $\rightarrow$ variable.shape
\end{enumerate}
\newpage

\section{Rights}

\paragraph{The contents of this PDF are largely derived (approximately 98\%) from W3Schools. It is not intended for commercial use; rather, I have compiled it as personal study notes. Feel free for anyone to read or integrate this material.}

\cleardoublepage

\end{document}
